package com.jingfm.tools;import java.lang.ref.SoftReference;import java.net.MalformedURLException;import java.util.HashMap;import android.graphics.Bitmap;import android.graphics.Bitmap.Config;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Matrix;import android.graphics.Paint;import android.graphics.PixelFormat;import android.graphics.PorterDuff.Mode;import android.graphics.PorterDuffXfermode;import android.graphics.Rect;import android.graphics.RectF;import android.graphics.drawable.Drawable;import android.view.View;import android.view.View.MeasureSpec;import com.jingfm.Constants.Constants;import com.jingfm.background_model.LocalCacheManager;public class AsyncImageLoader {	private static AsyncImageLoader instance;	public final static int  IMAGE_TYPE_ORIGINAL = 0;	public final static int  IMAGE_TYPE_ROUND = 1;	public final static int  IMAGE_TYPE_ROUND_CORNER = 2;	public static AsyncImageLoader getInstance() {		if (instance == null) {			instance = new AsyncImageLoader();		}		return instance;	}	private LocalCacheManager mLocalCacheManager;	private AsyncImageLoader() {	}		public String getTempPath(){		if (mLocalCacheManager == null) {			return "/mnt/sdcard/Jing/WebCache/" + Constants.CACHE_PATH_TEMP;		}		return mLocalCacheManager.getBasePath() + Constants.CACHE_PATH_TEMP;	}	public void setLocalCacheManager(LocalCacheManager localCacheManager){		mLocalCacheManager = localCacheManager;	}		/**	 * 内存图片软引用缓冲	 */	private HashMap<String, SoftReference<Bitmap>> imageCache = new HashMap<String, SoftReference<Bitmap>>();	/**	 * 	缓存在可清空目录中,纯静态,用户点击清除缓存就清除 	 *  给专辑封面用的	 */	public void loadBitmapByUrl(final String imageUrl,int type,			final ImageCallback callback) {		Bitmap rs = null;		if (mLocalCacheManager != null				&& mLocalCacheManager.isReady()) {			try {				SoftReference<Bitmap> sr = imageCache.get(imageUrl+type);				if (sr != null) {					rs = sr.get();					if (rs != null) {						callback.imageLoaded(rs, imageUrl);						return;					}				}				mLocalCacheManager.requestImageUrl(imageUrl,type,callback);//				imageCache.put(imageUrl, new SoftReference<Bitmap>(rs));			} catch (MalformedURLException e) {				e.printStackTrace();			}catch (Exception e) {				e.printStackTrace();			}		}	}			/**	 * 	缓存在可清空目录中，但是随用户更新而更新 	 *  给所有用户上传的主页封面和自己的头像用的	 */	public void loadUpdateBitmapByUrl(final String imageUrl,int type,			final ImageCallback callback) {		Bitmap rs = null;		if (mLocalCacheManager != null				&& mLocalCacheManager.isReady()) {			try {				SoftReference<Bitmap> sr = imageCache.get(imageUrl+type);				if (sr != null) {					rs = sr.get();					if (rs != null) {						callback.imageLoaded(rs, imageUrl);						return;					}				}				mLocalCacheManager.requestUpdateImageUrl(imageUrl,type,callback);				imageCache.put(imageUrl, new SoftReference<Bitmap>(rs));			} catch (MalformedURLException e) {				e.printStackTrace();			}catch (Exception e) {				e.printStackTrace();			}		}	}		/**	 * 	缓存在临时目录中,用户退出程序则清空	 *  给所有用户头像用的	 */	public synchronized void loadTempBitmapByUrl(final String imageUrl,int type,			final ImageCallback callback) {		Bitmap rs = null;		if (mLocalCacheManager != null				&& mLocalCacheManager.isReady()) {			try {				SoftReference<Bitmap> sr = imageCache.get(imageUrl+type);				if (sr != null) {					rs = sr.get();					if (rs != null) {						callback.imageLoaded(rs, imageUrl);						return;					}				}				mLocalCacheManager.requestImageUrl(imageUrl,type,Constants.CACHE_PATH_TEMP_IMAGE,callback);				imageCache.put(imageUrl, new SoftReference<Bitmap>(rs));			} catch (MalformedURLException e) {				e.printStackTrace();			}catch (Exception e) {				e.printStackTrace();			}		}	}		/**	 * 	缓存在临时备用目录中	 *  给离线模式备用的	 */	public synchronized void loadTempBakBitmapByUrl(final String imageUrl,int type,			final ImageCallback callback) {		Bitmap rs = null;		if (mLocalCacheManager != null				&& mLocalCacheManager.isReady()) {			try {//				SoftReference<Bitmap> sr = imageCache.get(imageUrl+type);//				将此逻辑改为软引用只保留原始图片				Bitmap bitmap = getBitMapFromSoftReference(imageUrl,type);				if (bitmap != null) {					callback.imageLoaded(bitmap, imageUrl);					return;				}				mLocalCacheManager.requestImageUrl(imageUrl,type,Constants.CACHE_PATH_TEMP_IMAGE_BAK,callback);//				imageCache.put(imageUrl, new SoftReference<Bitmap>(rs));			} catch (MalformedURLException e) {				e.printStackTrace();			}catch (Exception e) {				e.printStackTrace();			}		}	}		private Bitmap getBitMapFromSoftReference(String imageUrl, int type) {		SoftReference<Bitmap> sr = imageCache.get(imageUrl);		Bitmap rs = null;		if (sr != null) {			rs = sr.get();			if (rs != null) {				switch (type) {				case AsyncImageLoader.IMAGE_TYPE_ROUND:					rs = AsyncImageLoader.toRound(rs);					break;				case AsyncImageLoader.IMAGE_TYPE_ROUND_CORNER:					rs = AsyncImageLoader.toRoundCorner(rs);					break;				}			}		}		return rs;	}	public static Bitmap makeImageByType(String key,Bitmap bitmap,int type) {		if (bitmap == null || instance == null) {			return bitmap;		}		Bitmap rs = bitmap;		switch (type) {		case AsyncImageLoader.IMAGE_TYPE_ROUND:			rs = AsyncImageLoader.toRound(bitmap);			break;		case AsyncImageLoader.IMAGE_TYPE_ROUND_CORNER:			rs = AsyncImageLoader.toRoundCorner(bitmap);			break;		}//		instance.imageCache.put(key+type, new SoftReference<Bitmap>(rs));//		将此逻辑改为软引用只保留原始图片		instance.imageCache.put(key, new SoftReference<Bitmap>(rs));		return rs;	}		public static Bitmap toRound(Bitmap bitmap) { 		try {			int width = Math.max(bitmap.getWidth()/2, bitmap.getHeight()/2);			return toRoundCorner(bitmap,width) ;		} catch (Exception e) {			e.printStackTrace();		}catch (OutOfMemoryError e) {			e.printStackTrace();		}		return bitmap;	}		public static Bitmap toRoundCorner(Bitmap bitmap) {		try {//			int width = (int) (bitmap.getWidth()/200f * 6);			int width = (int) (bitmap.getWidth()/200f * 12);			return toRoundCorner(bitmap,width);		} catch (Exception e) {			e.printStackTrace();		}catch (OutOfMemoryError e) {			e.printStackTrace();		}		return bitmap;	}		public static Bitmap toRoundCorner(Bitmap bitmap, int width) {		if (bitmap == null || bitmap.isRecycled()) {			return null;		}		Bitmap output = null;		try {			output = Bitmap.createBitmap(bitmap.getWidth(),					bitmap.getHeight(), Config.ARGB_8888);			Canvas canvas = new Canvas(output);			Paint paint = new Paint();			Rect rect = new Rect(0, 0, bitmap.getWidth(), bitmap.getHeight());			RectF rectF = new RectF(rect);			float roundPx = bitmap.getWidth();			if (width == -1) {				roundPx = bitmap.getWidth();			} else {				roundPx = width;			}			paint.setAntiAlias(true);			canvas.drawARGB(0, 0, 0, 0);			canvas.drawRoundRect(rectF, roundPx, roundPx, paint);			paint.setXfermode(new PorterDuffXfermode(Mode.SRC_IN));			canvas.drawBitmap(bitmap, rect, rect, paint);		} catch (RuntimeException e) {			e.printStackTrace();		} catch (OutOfMemoryError e) {			e.printStackTrace();		}		return output;	}	public static  Bitmap toTopCorner(Bitmap bitmap, int width) {		Bitmap output = Bitmap.createBitmap(bitmap.getWidth(),				bitmap.getHeight(), Config.ARGB_8888);		Canvas canvas = new Canvas(output);		Paint paint = new Paint();		Rect rect = new Rect(0, 0, bitmap.getWidth(), bitmap.getHeight());		RectF rectF = new RectF(rect.left, rect.top, rect.right, rect.bottom				+ width);		float roundPx = bitmap.getWidth();		if (width == -1) {			roundPx = bitmap.getWidth();		} else {			roundPx = width;		}		paint.setAntiAlias(true);		canvas.drawARGB(0, 0, 0, 0);		canvas.drawRoundRect(rectF, roundPx, roundPx, paint);		paint.setXfermode(new PorterDuffXfermode(Mode.SRC_IN));		canvas.drawBitmap(bitmap, rect, rect, paint);		return output;	}		public static Bitmap bitmapRoom(Bitmap srcBitmap, int newHeight,			int newWidth) {		int srcWidth = srcBitmap.getWidth();		int srcHeight = srcBitmap.getHeight();		float scaleWidth = ((float) newWidth) / srcWidth;		float scaleHeight = ((float) newHeight) / srcHeight;		Matrix matrix = new Matrix();		matrix.postScale(scaleWidth, scaleHeight);		Bitmap resizedBitmap = Bitmap.createBitmap(srcBitmap, 0, 0, srcWidth,				srcHeight, matrix, true);		if (resizedBitmap != null) {			return resizedBitmap;		} else {			return srcBitmap;		}	}		public static Bitmap mergeBitmap(Bitmap background, Bitmap foreground) {		try {			if (background != null) {				int bgWidth = background.getWidth();				int bgHeight = background.getHeight();				int fgWidth = foreground.getWidth();				int fgHeight = foreground.getHeight();				Bitmap newmap = Bitmap.createBitmap(Math.max(bgWidth, fgWidth),						Math.max(bgHeight, fgHeight), Config.ARGB_8888);				Canvas canvas = new Canvas(newmap);				if (bgWidth > fgWidth) {					canvas.drawBitmap(background, 0, 0, null);					canvas.drawBitmap(foreground, Math.abs((bgWidth - fgWidth) / 2f),							Math.abs((bgHeight - fgHeight) / 2), null);				} else {					canvas.drawBitmap(background, Math.abs((bgWidth - fgWidth) / 2f),							Math.abs((bgHeight - fgHeight) / 2), null);					canvas.drawBitmap(foreground, 0, 0, null);				}				canvas.save(Canvas.ALL_SAVE_FLAG);				canvas.restore();				return newmap;			}		} catch (Exception e) {		} catch (OutOfMemoryError e) {		}		return null;	}		public static Bitmap mergeBitmap(Bitmap background, Bitmap foreground,float offsetX,float offsetY) {		try {			if (background != null) {				Bitmap newmap = Bitmap.createBitmap(background.getWidth(),background.getHeight(), Config.ARGB_8888);				Canvas canvas = new Canvas(newmap);				canvas.drawBitmap(background, 0, 0, null);				canvas.drawBitmap(foreground, offsetX,offsetY, null);				canvas.save(Canvas.ALL_SAVE_FLAG);				canvas.restore();				return newmap;			}		} catch (Exception e) {		} catch (OutOfMemoryError e) {		}		return null;	}		public static  Bitmap cutBitmap(Bitmap bitmap,int vW,int vH) {		int bW = bitmap.getWidth();		int bH = bitmap.getHeight();		if (bH > vH) {			bitmap = Bitmap.createScaledBitmap(bitmap, vH, vH, true);			bW = bitmap.getWidth();			bH = bitmap.getHeight();		}		int x = vW * bH/vH;		Rect rect = new Rect((bW -x)/2,0,bW - (bW -x)/2,bH);		Bitmap bitmap1 = AsyncImageLoader.cutBitmap(bitmap,rect,bitmap.getConfig());		if (bitmap1 == null) {			return bitmap;		}else{			return bitmap1;		}	}		private static Bitmap cutBitmap(Bitmap mBitmap, Rect r, Bitmap.Config config) {            int width = r.width();            int height = r.height();            Bitmap croppedImage = Bitmap.createBitmap(width, height, config);            Canvas canvas = new Canvas(croppedImage);         Rect dr = new Rect(0, 0, width, height);            canvas.drawBitmap(mBitmap, r, dr, null);          return croppedImage;  	}  			/**	 * 模糊效果	 * @param bmp	 * @return	 */ 	public static Bitmap blurImage(Bitmap bmpSource,int width,int height,int radius) {		if (bmpSource == null) {			return bmpSource;		}		bmpSource = Bitmap.createScaledBitmap(bmpSource, width, height, false);		int pixels[] = new int[bmpSource.getWidth() * bmpSource.getHeight()];  //颜色数组，一个像素对应一个元素		int pixelsOutTmp[] = new int[bmpSource.getWidth() * bmpSource.getHeight()];  //颜色数组，一个像素对应一个元素		int pixelsOut[] = new int[bmpSource.getWidth() * bmpSource.getHeight()];  //颜色数组，一个像素对应一个元素		bmpSource.getPixels(pixels, 0, bmpSource.getWidth(), 0, 0, bmpSource.getWidth(), bmpSource.getHeight());  //获取像素点		//应用到图像		blur(pixels,pixelsOutTmp,width,height,radius/2);		blur(pixelsOutTmp,pixelsOut,width,height,radius/2);		blur(pixels,pixelsOutTmp,width,height,radius/2);		blur(pixelsOutTmp,pixelsOut,width,height,radius/2);		Bitmap bmpReturn = Bitmap.createBitmap(bmpSource.getWidth(), bmpSource.getHeight(), Config.RGB_565);		bmpReturn.setPixels(pixelsOut, 0, bmpSource.getWidth(), 0, 0, bmpSource.getWidth(), bmpSource.getHeight());  //必须新建位图然后填充，不能直接填充源图像，否则内存报错		return bmpReturn;	} 		private static void blur( int[] in, int[] out, int width, int height, int radius ) {  		int widthMinus1 = width-1;  		int tableSize = 2*radius+1;  		int divide[] = new int[256*tableSize];  		// the value scope will be 0 to 255, and number of 0 is table size  		// will get means from index not calculate result again since   		// color value must be  between 0 and 255.  		for ( int i = 0; i < 256*tableSize; i++ )  			divide[i] = i/tableSize;   		int inIndex = 0;  		//   		for ( int y = 0; y < height; y++ ) {  			int outIndex = y;  			int ta = 0, tr = 0, tg = 0, tb = 0; // ARGB -> prepare for the alpha, red, green, blue color value.  			for ( int i = -radius; i <= radius; i++ ) {  				int rgb = in[inIndex +((i < 0) ? 0 : (i > width-1) ? width-1 : i)]; // read input pixel data here. table size data.  				ta += (rgb >> 24) & 0xff;  				tr += (rgb >> 16) & 0xff;  				tg += (rgb >> 8) & 0xff;  				tb += rgb & 0xff;  			}  			for ( int x = 0; x < width; x++ ) { // get output pixel data.  				out[ outIndex ] = (divide[ta] << 24) | (divide[tr] << 16) | (divide[tg] << 8) | divide[tb]; // calculate the output data.  				int i1 = x+radius+1;  				if ( i1 > widthMinus1 )  					i1 = widthMinus1;  				int i2 = x-radius;  				if ( i2 < 0 )  					i2 = 0;  				int rgb1 = in[inIndex+i1];  				int rgb2 = in[inIndex+i2];  				ta += ((rgb1 >> 24) & 0xff)-((rgb2 >> 24) & 0xff);  				tr += ((rgb1 & 0xff0000)-(rgb2 & 0xff0000)) >> 16;  				tg += ((rgb1 & 0xff00)-(rgb2 & 0xff00)) >> 8;  			tb += (rgb1 & 0xff)-(rgb2 & 0xff);  			outIndex += height; // per column or per row as cycle...  			}  			inIndex += width; // next (i+ column number * n, n=1....n-1)  		}  	}		/**	 * 高斯模糊	 * 	 * @param bmp	 * @return	 */	public static Bitmap convertToBlur(Bitmap bmp,int times) {		// 高斯矩阵		int[] gauss = new int[] { 1, 2, 1, 2, 4, 2, 1, 2, 1 };		int width = bmp.getWidth();		int height = bmp.getHeight();		Bitmap newBmp = Bitmap.createBitmap(width, height,				Bitmap.Config.RGB_565);		int pixR = 0;		int pixG = 0;		int pixB = 0;		int pixColor = 0;		int newR = 0;		int newG = 0;		int newB = 0;		int delta = 16; // 值越小图片会越亮，越大则越暗		int idx = 0;		int[] pixels = new int[width * height];		bmp.getPixels(pixels, 0, width, 0, 0, width, height);		if (times < 1) {			times = 1;		}		for (int indexTime = 0; indexTime < times; indexTime++) {			for (int i = 1, length = height - 1; i < length; i++) {				for (int k = 1, len = width - 1; k < len; k++) {					idx = 0;					for (int m = -1; m <= 1; m++) {						for (int n = -1; n <= 1; n++) {							pixColor = pixels[(i + m) * width + k + n];							pixR = Color.red(pixColor);							pixG = Color.green(pixColor);							pixB = Color.blue(pixColor);							newR = newR + pixR * gauss[idx];							newG = newG + pixG * gauss[idx];							newB = newB + pixB * gauss[idx];							idx++;						}					}					newR /= delta;					newG /= delta;					newB /= delta;					newR = Math.min(255, Math.max(0, newR));					newG = Math.min(255, Math.max(0, newG));					newB = Math.min(255, Math.max(0, newB));					pixels[i * width + k] = Color.argb(255, newR, newG, newB);					newR = 0;					newG = 0;					newB = 0;				}			}		}		newBmp.setPixels(pixels, 0, width, 0, 0, width, height);		return newBmp;	}		/**     * Drawable转化为Bitmap      */  	public static Bitmap drawableToBitmap(Drawable drawable) {    	    int width = drawable.getIntrinsicWidth();    	    int height = drawable.getIntrinsicHeight();    	    Bitmap bitmap = Bitmap.createBitmap(width, height,    	                                  drawable.getOpacity() != PixelFormat.OPAQUE ? Bitmap.Config.ARGB_8888: Bitmap.Config.RGB_565);    	    Canvas canvas = new Canvas(bitmap);    	    drawable.setBounds(0,0,width,height);    	    drawable.draw(canvas);    	    return bitmap;    	}   		public static Bitmap convertViewToBitmap(View view){		view.measure(MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED), MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED));        view.layout(0, 0, view.getMeasuredWidth(), view.getMeasuredHeight());        view.buildDrawingCache();        Bitmap bitmap = view.getDrawingCache();        return bitmap;	}			public interface ImageCallback {		public void imageLoaded(Bitmap bitmap, String imageUrl);	}}